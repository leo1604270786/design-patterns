## 前言

项目结构为Maven项目结构。

源代码目录：`src/main/java/com/zys/design/pattern`。

演示（测试）目录：`src/test/java/com/zys/design/pattern`。

各个设计模式在不同的包中，包名为设计模式名称。

## 设计模式

设计模式是指在软件开发中，`经过验证的`，用于解决`特定环境`下、`重复出现`的、`特定问题`的`解决方案`。

设计模式概览：

![设计模式](https://cdn.jsdelivr.net/gh/leo1604270786/imagebed@master/img/设计模式.png)

## 创建型

抽象了对象的实例化的过程，用来帮助创建对象的实例。

### 单例模式

**定义**：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

实现单例的两种方式：

- 懒汉式

  只有在第一次使用时才创建唯一实例。

- 饿汉式

  在初始化时就创建唯一实例。

单例模式主要实现的是**控制实例的数量**。

#### 使用场景

- 需要控制一个类的实例只有一个，而且客户端只能从一个全局访问点访问时。

### 简单工厂

简单工厂不是一个标准的设计模式，但用途非常广泛。

**定义**：提供一个创建实例的功能，无需关心其具体实现。被创建实例可以是 接口、抽象类、具体类。

由于创建实例方法大多数情况下是static的，所以也称为 `静态工厂`。

简单工厂内部主要实现的是**“选择合适的实现类”**来创建对象，既然是选择，那么必然需要选择的依据，通常来自于：

- 客户端的输入
- 配置文件
- 运行期的某个值（内存、数据库等）

**优点**

- 帮助封装

  简单工厂虽然简单，但可以帮我们实现组件的封装，让外部真正实现面向接口编程。

- 解耦

  简单工厂可以让客户端和具体实现解耦，客户端不需要知道具体的实现，通过工厂就可以获取对应接口类型对象。

**缺点**：

- 增加客户端的复杂度

  客户端需要知道每个输入条件的功能与含义，会增加客户端的复杂度，也会暴露部分实现。

- 不易于实现的拓展

  每次添加新的实现需要修改工厂代码。

#### 使用场景

- 完全封装隔离具体的实现，让外部只能通过接口操作封装体。
- 想把对外创建对象的职责集中管理和控制。

### 工厂方法

**定义**：定义一个用于创建对象的接口，让子类去决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。

**主要功能**：让父类在不知道具体实现的情况下，完成自身的功能调用，而具体的实现延迟到子类完成。

**优点**

- 可以在不知道具体实现的情况下编程

  工厂方法模式可以让你在实现功能时，如果需要某个对象，直接使用对象实现的接口，无需关心具体的实现。具体的实现延迟到子类去完成。

- 更容易扩展对象

  工厂方法给子类提供了一个挂钩，使得扩展新的对象变得很容易。

- 连接平行的类层次

  > 平行的类层次：假设有两个类层次，其中一个类层次中的每个类在另一个类层次中都有一个对应的类的结构，就称为平行的类层次结构。

**缺点**

- 具体的产品对象与工厂方法耦合

工厂方法的本质是：**延迟到子类来选择实现**。

#### 使用场景

- 一个类需要创建某个接口的对象，又不知道具体实现。
- 一个类需要子类来创建所需的对象。

### 抽象工厂

**定义**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

**优点**

- 分离接口与实现

  客户端用过抽象工厂来创建产品对象，不需要知道具体的实现，只需要面向产品对象的接口编程。

- 是切换产品簇变得方便

  一个具体的工厂实现代表一个产品簇，客户端选择不同的实现工厂就相当于选择了不同的产品簇。

**缺点**

- 不太容易扩展新的产品

  如果需要在一个产品簇中添加一个产品，需要修改抽象工厂。而修改抽象工厂就需要修改所有的实现工厂。

- 容易造成类层次复杂

  如果需要选择的层次过多，那么类层次就会变得复杂。

抽象工厂的本质：**选择产品簇的实现**。

#### 使用场景

- 希望一个系统只知道产品的接口，而不关心具体的实现的时候。
- 可以动态切换产品簇的时候。
- 强调一系列相关产品的接口，联合使用的时候。

### 建造者模式

**定义**：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

建造者模式的主要功能是：构建复杂的产品，而且是细化的、分步骤的构建。并且构建的过程是统一不变的，而各个部分具体的构建实现是可以变化的。

**建造者模式的构成**

- Builder，定义了如何构造各个部件，也就是知道每个部件是如何实现的，并且知道如何将部件装配到产品中。
- Director，定义了构建产品的算法（过程）。

**优点**

- 松散耦合

  建造者模式可以将同一个构建算法构建出表现上完全不同的产品。实现产品的构建过程与产品的表现分离。

- 容易改变产品的内部表示

  需要改变产品的表示，只需要切换具体的Builder实现。

- 更好的复用性

  建造者模式将构建算法和具体产品实现分离，使得构建算法可以复用，产品实现也可以使用不同的构建算法进行构建。

建造者模式的本质是：**分离整体构建算法和部件实现**。

#### 使用场景

- 创建对象的算法，独立于对象的组成部分以及它们的装配方式时。
- 同一个构建过程有不同的表示时。

### 原型模式



## 结构型

描述如何组合类和对象，以获得更大的结构。

### 代理模式

**定义**：为其他对象提供一种代理以控制对这个对象的访问。

代理模式的本质是：**控制对象的访问**。

#### 使用场景

- 需要为一个对象在不同的地址空间提供局部代表时，使用远程代理。
- 按照需要创建开销很大的对象时，使用虚代理。
- 需要控制对原始对象的访问时，使用保护代理。
- 需要为原始对象添加额外功能时，使用智能指引代理。

### 桥接模式

**定义**：将抽象部分与它的实现部分分离，使得它们可以独立地变化。

**优点**

- 分离抽象和实现部分

  桥接模式分离了抽象部分和实现部分，极大提高了系统的灵活性。

- 更好的扩展性

  由于桥接模式分离了抽象部分和实现部分，所以抽象部分和实现部分可以分别扩展，不会相互影响。

- 可动态切换实现

  由于桥接模式分离了抽象部分和实现部分，所以在实现桥接的时候，可以动态的选择具体的实现。

- 可减少子类的数量

  对于有两个纬度的变化的时候，使用桥接模式实现比使用继承实现产生更少的子类。

桥接模式的本质是：**分离抽象和实现**。

#### 使用场景

- 不希望抽象部分和实现部分采用固定的绑定关系。
- 抽象部分和实现部分都能够扩展。
- 实现部分的修改不会对客户端产生影响。
- 替代继承，减少子类数量。

### 装饰者模式

**定义**：动态的给一个对象添加一些额外的职责，就添加功能而言，装饰者模式比生成子类更灵活。

**优点**

- 比继承更灵活

- 更容易复用功能

  将一系列功能分散到每个装饰器中，每个装饰器一般只实现一个功能，使装饰器变得简单，更易复用。

- 简化高层定义

  在装饰者模式中，可以通过组合装饰器的方式为对象添加任意多的功能，无需在高层全部定义出来。

**缺点**

- 会产生许多细粒度的对象

装饰者模式的本质是：**动态组合**。

#### 使用场景

- 在不影响其他对象的情况下，为对象动态、透明的添加职责时。
- 不适合使用子类进行扩展时。

### 适配器模式

**定义**：将一个类的接口转换成客户端希望的另一个接口。适配器模式使得那些原本由于接口不兼容而不能一起工作的类可以一起工作。

**优点**

- 更好的复用性

  如果功能已经实现，只是接口不兼容，那么适配器模式可以很好的复用这些功能。

- 更好的扩展性

**缺点**

- 过多的使用适配器会使系统变得零乱，不易于整体把控。

适配器模式的本质是：**转换匹配，复用功能**。

#### 使用场景

- 使用现有的类，但接口不符合需求。
- 创建一个可复用的类，可以与不兼容的类一起工作。

## 行为型

描述算法和对象之间职责的分配。

### 观察者模式

**定义**：定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知，并被自动更新。

**优点**

- 观察者和目标对象抽象耦合

- 实现了动态联动

  联动就是做一个操作，会引起其他相关操作。

- 支持广播通信

**缺点**

- 广播通信可能会引起无谓的操作

观察者模式的本质是：**触发联动**。

#### 使用场景

- 当抽象模型有两个方面，且一个方面的操作依赖于另一个方面的状态变化。
- 修改一个对象时，需要修改其他对象，且其他对象的数量不清楚。
- 当一个对象需要通知其他对象，且该对象保持与其他对象松散耦合。

### 模版方法模式

**定义**：定义一个操作中的算法的骨架，将一些步骤延迟到子类中实现。模版方法模式使得子类可以不改变一个算法的结构即可重新定义该算法的某些特定步骤。

**优点**

- 代码复用

  子类公共部分提取到父类模版中实现。

**缺点**

- 算法骨架不容易升级

模版方法模式的本质是：**固定算法骨架**。

#### 使用场景

- 需要固定算法骨架，将变化的部分留给子类实现。
- 需要控制子类的扩展情况，只允许子类扩展算法中某几个步骤。

### 策略模式

**定义**：定义一系列算法，将它们一个个都封装起来，并且使它们可以相互替换。

> 策略算法是相同行为的不同实现。

**优点**

- 避免多重条件语句
- 更好的扩展性

**缺点**

- 客户端必须了解每个策略的功能和不同，需要选择使用哪个策略
- 增加了类的数目。每个算法都由一个类来实现。
- 只适合扁平的算法结构。因为每个算法都是平等的、可以互相替换的。

策略模式的本质是：**分离算法，选择实现**。

#### 使用场景

- 多个相关的类，只有行为有差别的情况下。
- 同一个算法，有多个不同的实现时。
- 替换多重条件判断语句。

### 责任链模式

**定义**：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。并将这些对象连成一条链，将请求沿着这条链传递，直到请求被处理。

**优点**

- 请求者和接受者的松散耦合
- 动态组合职责

**缺点**

- 产生很多细粒度对象。一般每个职责对象只处理一各方面的功能。
- 请求不一定被处理。

责任链模式的本质：**分离职责，动态组合**。

#### 使用场景

- 有多个对象可以处理同一个请求，但具体的处理对象不确定。
- 动态指定一个请求的处理对象集合。

### 迭代器模式

**定义**：提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。

**优点**

- 更好的封装性
- 访问一个聚合对象中的内容，而又不暴露该对象的内部表示
- 可以以不同的方式遍历一个聚合对象
- 为不同的聚合对象提供了统一的接口，方便客户端调用

迭代器模式的本质是：**控制访问聚合对象中的元素**。

#### 使用场景

- 希望访问一个聚合对象中的内容，而又不暴露该对象的内部表示
- 希望以多种遍历方式访问一个聚合对象
- 为不同的聚合对象提供统一的遍历接口

### 状态模式








